/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2016-2023 Objectionary.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package org.eolang.maven.it;

import com.yegor256.Jaxec;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.cactoos.Input;
import org.cactoos.io.InputOf;
import org.cactoos.iterable.Mapped;
import org.eolang.jucs.ClasspathSource;
import org.eolang.maven.AssembleMojo;
import org.eolang.maven.DemandMojo;
import org.eolang.maven.FakeMaven;
import org.eolang.maven.OnlineCondition;
import org.eolang.maven.RegisterMojo;
import org.eolang.maven.TranspileMojo;
import org.eolang.maven.hash.ChRemote;
import org.eolang.maven.hash.CommitHash;
import org.eolang.maven.objectionary.Objectionaries;
import org.eolang.maven.objectionary.OyFilesystem;
import org.eolang.maven.util.Walk;
import org.hamcrest.MatcherAssert;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.extension.ConditionEvaluationResult;
import org.junit.jupiter.api.extension.ExecutionCondition;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.io.TempDir;
import org.junit.jupiter.params.ParameterizedTest;
import org.yaml.snakeyaml.Yaml;

/**
 * Integration test for simple snippets.
 *
 * This test will/may fail if you change something in {@code to-java.xsl}
 * or some other place where Java sources are generated. This happens
 * because this test relies on {@code eo-runtime.jar}, which it finds in your local
 * Maven repository. This file is supposed to be generated by a previous run
 * of Maven, but will not exist at the first run. Thus, when changes are made
 * it is recommended to disable this test. Then, when new {@code eo-runtime.jar} is
 * released, you enable this test again.
 *
 * @since 0.1
 * @todo #1107:30m Method `jdkExecutable` is duplicated in eo-runtime.
 *  Find a way to make it reusable (i.e making it part of
 *  VerboseProcess) and remove it from MainTest.
 */
@ExtendWith(OnlineCondition.class)
@SuppressWarnings("JTCOP.RuleAllTestsHaveProductionClass")
final class SnippetTestCase {

    /**
     * Temp dir.
     * @checkstyle VisibilityModifierCheck (5 lines)
     */
    @TempDir
    public Path temp;

    /**
     * Runs and checks of eo snippets.
     *
     * @param yml Yaml test case.
     * @throws Exception If fails
     */
    @ParameterizedTest
    @ExtendWith(OnlineCondition.class)
    @SuppressWarnings("unchecked")
    @ClasspathSource(value = "org/eolang/maven/snippets/", glob = "**.yaml")
    @ExtendWith(RuntimeLibraryExists.class)
    void runsAllSnippets(final String yml) throws Exception {
        final Yaml yaml = new Yaml();
        final Map<String, Object> map = yaml.load(yml);
        final String stdout = SnippetTestCase.run(
            this.temp,
            new InputOf(String.format("%s\n", map.get("eo"))),
            (List<String>) map.get("args"),
            map.get("in").toString()
        );
        MatcherAssert.assertThat(
            String.format("'%s' printed something wrong", yml),
            stdout,
            Matchers.allOf(
                new Mapped<>(
                    ptn -> Matchers.matchesPattern(
                        Pattern.compile(ptn, Pattern.DOTALL | Pattern.MULTILINE)
                    ),
                    (Iterable<String>) map.get("out")
                )
            )
        );
    }

    /**
     * Classpath.
     * @return Classpath.
     */
    static String classpath() {
        return String.format(
            ".%s%s",
            File.pathSeparatorChar,
            Paths.get(System.getProperty("user.home"))
                .resolve(
                    String.format(
                        ".m2/repository/org/eolang/eo-runtime/%s/eo-runtime-%1$s.jar",
                        "1.0-SNAPSHOT"
                    )
                )
        );
    }

    /**
     * Compile EO to Java and run.
     * @param tmp Temp dir
     * @param code EO sources
     * @param args Command line arguments
     * @param stdin The input
     * @return Stdout
     * @throws Exception If fails
     * @checkstyle ParameterNumberCheck (5 lines)
     */
    @SuppressWarnings({"unchecked", "PMD.ExcessiveMethodLength"})
    private static String run(
        final Path tmp,
        final Input code,
        final List<String> args,
        final String stdin
    ) throws Exception {
        final Path src = tmp.resolve("src");
        final CommitHash hash = new ChRemote("master");
        final FakeMaven maven = new FakeMaven(tmp)
            .withProgram(code)
            .with("sourcesDir", src.toFile())
            .with("objects", Arrays.asList("org.eolang.bool"))
            .with("hash", hash)
            .with("objectionaries", new Objectionaries.Fake(new OyFilesystem()));
        maven.execute(RegisterMojo.class);
        maven.execute(DemandMojo.class);
        maven.execute(AssembleMojo.class);
        maven.execute(TranspileMojo.class);
        final Path classes = maven.targetPath().resolve("classes");
        SnippetTestCase.compileJava(maven.generatedPath(), classes);
        return SnippetTestCase.runJava(args, stdin, classes);
    }

    /**
     * Compile Java sources.
     * @param generated Where to find Java sources
     * @param classes Where to put compiled classes
     */
    private static void compileJava(final Path generated, final Path classes) {
        new Jaxec(
            SnippetTestCase.jdkExecutable("javac"),
            "-encoding", "utf-8",
            new Walk(generated).stream()
                .map(Path::toAbsolutePath)
                .map(Path::toString)
                .collect(Collectors.joining(" ")),
            "-d", classes.toString(),
            "-cp", SnippetTestCase.classpath()
        ).withHome(generated).exec();
    }

    /**
     * Run Java.
     * @param args Command line arguments
     * @param stdin The input
     * @param classes Where to find compiled classes
     * @return The stdout
     * @checkstyle ParameterNumberCheck (5 lines)
     */
    private static String runJava(final List<String> args, final String stdin,
        final Path classes) {
        return new Jaxec()
            .with(
                SnippetTestCase.jdkExecutable("java"),
                "-Dfile.encoding=UTF-8",
                "-Dsun.stdout.encoding=UTF-8",
                "-Dsun.stderr.encoding=UTF-8",
                "-cp",
                SnippetTestCase.classpath(),
                "org.eolang.Main"
            )
            .with(args)
            .withHome(classes)
            .withStdin(stdin)
            .exec();
    }

    /**
     * Locate executable inside JAVA_HOME.
     * @param name Name of executable.
     * @return Path to java executable.
     */
    private static String jdkExecutable(final String name) {
        final String result;
        final String relative = "%s/bin/%s";
        final String property = System.getProperty("java.home");
        if (property == null) {
            final String environ = System.getenv("JAVA_HOME");
            if (environ == null) {
                result = name;
            } else {
                result = String.format(relative, environ, name);
            }
        } else {
            result = String.format(relative, property, name);
        }
        return result;
    }

    /**
     * Checks if runtime library exists.
     *
     * @since 0.30
     */
    public static class RuntimeLibraryExists implements ExecutionCondition {

        @Override
        public ConditionEvaluationResult evaluateExecutionCondition(final ExtensionContext ctx) {
            ConditionEvaluationResult ret;
            try {
                final String classpath = SnippetTestCase.classpath();
                if (Files.exists(Paths.get(classpath))) {
                    ret = ConditionEvaluationResult.enabled(
                        String.format("Runtime library '%s' is found successfully", classpath)
                    );
                } else {
                    ret = ConditionEvaluationResult.disabled("Runtime library is not found");
                }
            } catch (final InvalidPathException exception) {
                ret = ConditionEvaluationResult.disabled(
                    "Runtime library can't be found",
                    exception.getMessage()
                );
            }
            return ret;
        }
    }
}
